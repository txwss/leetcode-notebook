# 二叉树练习

## 剑指 Offer 27. 二叉树的镜像

来自 <https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/> 
![image](https://user-images.githubusercontent.com/22584921/148521401-b723494a-1903-47e5-abde-173ae70dde37.png)


这道题目看成是一个先序遍历的方法，先处理中心节点，再处理左节点，在处理右节点。那么这道题目的解法就有利用栈，或者是利用递归的思想。相比而言，递归的思想可能简洁一点，但是思考比较绕
```python

# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

#递归解法
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        def switch( node):
            if not node:
                return
            node.left, node.right = node.right,node.left
            switch(node.left)
            switch(node.right)
            return node
        root = switch(root)
        return root
#栈解法
class Solution:
    def mirrorTree(self, root: TreeNode) -> TreeNode:
        if not root: return
        stack = [root]
        while stack:
            node = stack.pop()
            if node.left: stack.append(node.left)
            if node.right: stack.append(node.right)
            node.left, node.right = node.right, node.left
        return root

```










## 之字型二叉树打印
### 自解思路
从题目可知，这种打印题目是要一层一层的打印出来的，所以需要的基本解题思路应该是利用二叉树的层级遍历方法， 二叉树的层级遍历用的是队列的方法，该题目在写的时候也考虑了队列或者栈来实现。
但是一个栈或者堆应该较难实现之字打印，因为需要有两个方向的打印过程，所以设计了两个栈，一个用来存储偶数层的数值，一个用来存储奇数层的数值

```python
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param pRoot TreeNode类 
# @return int整型二维数组
#
class Solution:
    def Print(self , pRoot: TreeNode) -> List[List[int]]:
        # write code here
        if not pRoot: return None
        one, two = [pRoot],[]
        res = []
        while one or two:
            if len(one)!=0:
                one_res = []
                while one:
                    node = one.pop()
                    one_res.append(node.val)
                    if node.left: two.append(node.left)
                    if node.right: two.append(node.right)
                res.append(one_res)
                continue
            elif len(two)!=0:
                two_res = []
                while two:
                    node = two.pop()
                    two_res.append(node.val)
                    if node.right: one.append(node.right)
                    if node.left: one.append(node.left)
                res.append(two_res)
                continue
        return res
```
